1.
第一题：输入学生的ID和他上的课程，找到每两个学生上的相同的课程。
例如，输入{{"58", "A"},  {"94", "B"},  {"17", "A"},  {"58", "B"},  ‍‍‍‍‌‍‍‌‍‌‍‍‌‍‌‌‌{"17", "B"},  {"58", "C"}}
输出:[58, 94]: [B]
        [58, 17]: [A, B]
        [94, 17]: []
第二题：给出一些课程和课程的先修课，每个课程有且只有一门先修课，并且保证学生只有一条path修完所有课程，求修到一半时的课程名称。
例如，输入{{A, B}, {C, D}, {B, C}, {E, F}, {D, E}, {F, G}}, 输出 D.
第三题: 第二题的follow up,假设每门课程可以有多门先修课,找出所有path修到一半课程的名称


2.
第一题：类似meeting rooms，输入是一个int[][] meetings, int start, int end, 每个数都是时间，13：00 =》 1300， 9：30 =》 930， 看新的meeting 能不能安排到meetings
ex: {[1300, 1500], [930, 1200],[830, 845]}, 新的meeting[820, 830], return true; [1450, 1500] return false;
第二题：类似merge interval，唯一的区别是输出，输出空闲的时间段，merge完后，再把两两个之间的空的输出就好，注意要加上0 - 第一个的start time
第三题：是给会议分配房间。已知每个会议的人数、开始时间、结束时间，以及每个房间的容量。
输入：
    会议列表：每个会议有名称、人数、开始时间、结束时间
    房间列表：每个房间有名称、容量。.本文原创自1point3acres论坛
   
    输出：
    每个会议安排在哪个房间，格式是“会议名:房间名”
    如果没法都安排，输出"impossible"

3.
calculator三组题
第一问：输入string 只有加减和数字，如"1+2-3"。 用一个整数存数字前面的符号。
第二问：第一问的基础上加括号，如"(1+2)-3"。用Stack存括号前面“真正”的符号, 遇到符号乘上stack.peek()
第三问：第二问的基础上加上变量，给了一部分变量对应的值，化简表达式。如"(a+b)+c+d+1", 给map {"a":1,"b":2,"c":3},输出"7+d"。用另外一个map存没有出现的变量的出现次数，其余变量or数字直接加到结果里面。


4.
第一题 :
给广告在每个domain上被click的次数. 要求返回domain及其所有sub domain 被click的总次数.
leetcode811 上有原题: https://leetcode.com/problems/subdomain-visit-count/

第二题:
给每个user访问历史记录，找出两个user之间longest continuous common history.

第三题:
这道题好像没在地里看到过. 统计点击广告的数量以及最后购买的数量. given 三个 list, 包括 purchasedUser(所有购买用户id), 
ipaddressUser(IP地址和用户对应列表), history(浏览记录, 包括IP地址, 时间 和 商品(广告)). 
应该就 split 一下, 然后提取一下所有的数据, 遍历一下 history 就好.
第三题相当于是这样
String[] purchasedUser = ["203948535", "56856", "b86785"]
String[] history = ["234.64.23.123,2018.10.3,item A",
"234.457.45.123,2018.10.3,item A",
"34.62.34.3,2018.10.3,item B"]
String[] ipaddressUser = ["203948535,234.457.2345.123",
"74545,234.457.2345.123"
"2347,234.64.23.123"
]
比如 item A 有两个点击记录, 但实际上对应的 ip 地址所对应的用户 id 只有一人最终购买, 所以输出的就是这样的形式:
1 of 2 item A
给出两个pair vector
{访问者ip和对应访问网站的text}
{用户id和对应ip}
再加上购买者的id vector
返回每个网站text 所对应购买数和访问数


5.
第一题 :
先是一个01矩阵里找一个矩形的岛的坐标
第二题:
找两个岛的坐标，然后followup，找不定数目的岛。第三个代码没写完。记得好像是找每个岛的上下左右界，不仅仅是单纯的岛的个数。
第三题:
Intuit 网上coding competition的一道题给一个矩阵，矩阵里的每个元素是1，但是其中分布着一些长方形区域， 这些长方形区域中的元素为0. 要求输出每个长方形的位置（用长方形的左上角元素坐标和右下角元素坐标表示）。
example：
input:.
[
[1,1,1,1,1,1],
[0,0,1,0,1,1],
[0,0,1,0,1,0],
[1,1,1,0,1,0],
[1,0,0,1,1,1]
].
output:
[
[1,0,2,1],
[1,3,3,3],
[2,5,3,5],
[4,1,4,2]
]
如果 Matrix 中有多个由0组成的长方体，请返回多套值（前提每两个长方体之间是不会连接的，所以放心）. 不改变输入的做法
不过还有第三问，就是connected components
第三问 基本上就是leetcode connected components,只不过是返回一个listoflist，每个list是一个component的所有点坐标
那个图是1,01,0组成的矩阵，0组成的就是各种图形。跟前面关系的确不大
如果矩阵里有多个不规则的形状，返回这些形状。这里需要自己思考并定义何谓“返回这些形状”


6.
题目是原先OA的拓展，employee的问题。给两个list，第一个list存了每个人的id，名字，公司名称。第二个list存friendship tuples。
然后有两问，第一问是返回每个人的friendlist。第二问是返回每个公司有多少员工，以及这些员工中有多少有外公司的朋友。然后两问都要给时间空间复杂度。图的问题，第二问时间复杂度是O(E+V).

Other:
LC366